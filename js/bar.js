// Has the bar chart been loaded yet?
bar_loaded = false;
// Has an individual player's set of lines been loaded yet?
player_loaded = false;

/***
 * Draw the bar chart based on the data in "linked_data" (generated by
 * scatterchart.js).
 * The first item in linked_data will always be the averages across all players.
 */
function renderBarChart(selected_data) {

    // If we've already loaded the bar chart once, simply update its values
    if (bar_loaded == true) {
        redrawBarChart(selected_data);
        return;
    }
    
    // Otherwise...    
    // Set size and margin of the bar chart
    var margin = {top: 20, right: 20, bottom: 30, left: 40},
        height = $(document).height()/4;
        width = $(document).width()/2 - 75;
        
	// Calculate the local averages of each stat
	var local_averages = getAverages(selected_data, all_sig);

	// The data we actually want to show is just the difference between total and local averages
	var data = [];
	for (var i in all_sig) {
		var indicator = all_sig[i];
		var percent_change = 100 * (local_averages[indicator] - global_averages[indicator]) / (local_averages[indicator] + global_averages[indicator]);
		data.push({"indicator": indicator, "difference": percent_change});
	}
	
	// Set the x-axis scale based on the different indicators
	x = d3.scale.ordinal()
		.domain(data.map(function(d) { return d["indicator"]; }))
		.rangeRoundBands([0, width], .1);

	// Set the y-axis scale on a range from -100 to 100 (since it shows % difference)
	y = d3.scale.linear()
		.domain([-100, 100])
		.range([height, 0]);

	yAxis = d3.svg.axis()
		.scale(y)
		.orient("left")
	
	// Add the bar chart svg to the actual HTML
    bar_svg = d3.select("#bar_chart_container").append("svg")
        .attr("id", "bar_chart")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    // Add the indicator labels for the bars along the bottom of the chart
    var i = 0;
    bar_svg.selectAll(".bar")
      .data(data)
    .enter().append("text")
      .attr("x", function(d) { return x(d["indicator"]) + x.rangeBand()/4; })
      .attr("y", function(d) { return height + margin.bottom - (i++%2) * (margin.bottom/2); })
      .text(function(d) { return abbreviate(d["indicator"]); });

	// Add the y-axis
	bar_svg.append("g")
      .attr("class", "bar_y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", -margin.left)
      .attr("x", -height/2 + margin.left + 25)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("% Deviation from Average");

	// Add the x-axis (which is just a single line)
	bar_svg.append("g")
      .attr("class", "bar_x axis")
    .append("line")
      .attr("y1", y(0))
      .attr("y2", y(0))
      .attr("x2", width);

	// Actually draw the bars, some of which are negative
    bar_svg.selectAll(".bar")
      .data(data)
    .enter().append("rect")
      .attr("class", function(d) { 
      
            // Assign appropriate coloring to the bar based on which playstyle it influences
            if (team_pos.indexOf(d["indicator"]) != -1) 
                return "team_bar";
            else if (team_neg.indexOf(d["indicator"]) != -1)
                return "individual_bar";
            else if (reck_pos.indexOf(d["indicator"]) != -1)
                return "reckless_bar";
            else 
                return "cautious_bar";
        })
      .attr("x", function(d) { return x(d["indicator"]); })
      .attr("y", function(d) { return y(Math.max(0, d["difference"])); })
      .attr("width", x.rangeBand())
      .attr("height", function(d) { return Math.abs(y(d["difference"]) - y(0)); })
      .on("mouseover", function(d) { 

            // Outline the selected bar
            d3.select(this).style("stroke-width", 2).style("stroke", "#000");

            // Show the tooltip
            d3.select("#bar_chart_tooltip").style("visibility", "visible");
            d3.select("#bar_chart_tooltip").html(d["indicator"] + "<br />Difference: " + precise_round(d["difference"], 2) + "%")  
                .style("left", (d3.event.pageX) + 10 + "px")     
                .style("top", (d3.event.pageY - 28) + "px");    
            })
        .on("mouseout", function(d) {

            // Remove outline
            d3.select(this).style("stroke-width", 0);

            // Hide the tooltip
            d3.select("#bar_chart_tooltip").style("visibility", "hidden");
        });
    
    // The bar chart has now been loaded!
    bar_loaded = true;
}

/***
 * Update the bar chart to reflect the new selection of data.
 */
function redrawBarChart(selected_data) {

    // Get the bar chart's SVG 
    var bar_svg = d3.select("#bar_chart");

    // Check to make sure that is at least one playstyle selected 
    if (playstyles.length == 0) {
    
        // If there isn't, just fill the bar chart with empty bars
        var data = [];
        for (var i in all_sig) {
            var indicator = all_sig[i];
            data.push({"indicator": indicator, "difference": 0});
        }

        // Update the bars
        bar_svg.selectAll("rect")
            .data(data)
          .transition()
            .duration(1000)
            .attr("y", function(d) { return y(Math.max(0, d["difference"])); })
            .attr("height", function(d) { return Math.abs(y(d["difference"]) - y(0)); })
            
        return;
    }
	
	// Calculate the local averages of each stat
	var local_averages = getAverages(selected_data, all_sig);

	// The data we actually want to show is just the difference between total and local averages
	var data = [];
	for (var i in all_sig) {
		var indicator = all_sig[i];
		var percent_change = 100 * (local_averages[indicator] - global_averages[indicator]) / (local_averages[indicator] + global_averages[indicator]);
		data.push({"indicator": indicator, "difference": percent_change});
	}
	
	// Change the height of the bars
	bar_svg.selectAll("rect")
		.data(data)
	  .transition()
	    .duration(1000)
  	    .attr("y", function(d) { return y(Math.max(0, d["difference"])); })
	    .attr("height", function(d) { return Math.abs(y(d["difference"]) - y(0)); })
}

/***
 * Update the bar chart to reflect the new selection of data.
 */
function showPlayerOnBarChart(player) {

	// The data we want to show this time is the difference between this player and the global averages
	var data = [];
	for (var i in all_sig) {
		var indicator = all_sig[i];
		var percent_change = 100 * (parseFloat(player[indicator]) - global_averages[indicator]) / (parseFloat(player[indicator]) + global_averages[indicator]);
		data.push({"indicator": indicator, "difference": percent_change});
	}

    // If this is the first time we're drawing lines for individual players...    
    if (player_loaded == false) {

        // Add the lines to the bar svg!
        bar_svg.selectAll(".player_line")
          .data(data)
        .enter().append("line")
          .attr("class", "player_line")
          .attr("x1", function(d) { return x(d["indicator"]); })
          .attr("x2", function(d) { return x(d["indicator"]) + x.rangeBand(); })
          .attr("y1", function(d) { return y(d["difference"]) })
          .attr("y2", function(d) { return y(d["difference"]) })
        
        // Remember that a single player has been loaded
        player_loaded = true;
    }
    
	// Otherwise we just need to update the player's lines
    else {
        bar_svg.selectAll(".player_line")
            .data(data)
          .transition()
            .duration(1000)
            .attr("y1", function(d) { return y(d["difference"]) })
            .attr("y2", function(d) { return y(d["difference"]) })
    }
}

/***
 * Return an abbreviated version of the given string. Will be used for bar
 * chart labels.
 */
function abbreviate(indicator) {
    var abbreviation = "";
    var by_spaces = indicator.split(" ");
    if (by_spaces.length == 2) {
        var by_slash = by_spaces[1].split("/");
        abbreviation = (by_spaces[0][0] + by_slash[0][0] + '/' + by_slash[1][0]);
    }
    else {
        var by_slash = by_spaces[0].split("/");
        abbreviation = (by_slash[0][0] + '/' + by_slash[1][0]);
    }
    return abbreviation;
}